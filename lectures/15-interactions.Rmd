---
title: 'Interactions (II)'
output:
  xaringan::moon_reader:
    lib_dir: libs
    css: [default, rladies, rladies-fonts, "my-theme.css"]
    incremental: true
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
---

## Last time...

Introduction to interactions with one categorical and one continuous predictor


## Today

Two continuous predictors

---

## What are interactions?

When we have two variables, A and B, in a regression model, we are testing whether these variables have **additive effects** on our outcome, Y. That is, the effect of A on Y is constant over all values of B. 

- Example: Drinking coffee and hours of sleep have additive effects on alertness; no matter how any hours I slept the previous night, drinking one cup of coffee will make me .5 SD more awake than not drinking coffee. 
---

## What are interactions?

However, we may hypothesis that two variables have **joint effects**, or interact with each other. In this case, the effect of A on Y changes as a function of B. 

- Example: Chronic stress has a negative impact on health but only for individuals who receive little or no social support; for individuals with high social support, chronic stress has no impact on health. 

- This is also referred to as **moderation.** 

- The **"interaction term"** is the regression coefficient that tests this hypothesis. 

---
.pull-left[
### Univariate regression

```{r, echo = F, message = F, warning = F, fig.width = 4.5}
library(tidyverse)
set.seed(022020)
x = rnorm(n = 20)
z = rnorm(n = 20)
y  = x*z + rnorm(n = 20)
data.frame(x,y) %>%
  ggplot(aes(x,y)) + geom_point() + geom_smooth(method = 'lm', se = F) + theme_bw()
```

]
.pull-right[
### Multivariate regression

```{r, echo = F, fig.width=4.5}
library(visreg)
x1 = x
x2 = z
mr.model = lm(y ~ x1 + x2)
visreg2d(mr.model,"x1", "x2", plot.type = "persp")

```

]
---


### Multivariate regression with an interaction

```{r, echo = F, fig.width = 10, fig.height = 8}
mr.model2 = lm(y ~ x1*x2)
visreg2d(mr.model2,"x1", "x2", plot.type = "persp")
```
---

### Example

Here we have an outcome (`Stress`) that we are interested in predicting from trait `Anxiety` and levels of social `Support`.

```{r, message=FALSE, warning = F}
library(tidyverse)
stress.data = read_csv("https://raw.githubusercontent.com/uopsych/psy612/master/data/stress.csv")
glimpse(stress.data)
psych::describe(stress.data, fast = T)
```

---

```{r}
imodel = lm(Stress ~ Anxiety*Support, data = stress.data)
summary(imodel)
```

```{r, echo = F}
mod.c = round(coef(imodel),2)
```

$$\hat{Stress} = `r mod.c[1]` + `r mod.c[2]`(Anx) + `r mod.c[3]`(Sup) + `r mod.c[4]`(Anx \times Sup)$$
---

## Conditional effects and simple slopes

The regression line estimated in this model is quite difficult to interpret on its own. A good strategy is to decompose the regression equation into **simple slopes**, which are determined by calculating the conditional effects at a specific level of the moderating variable.

- Simple slope: the equation for Y on X at differnt levels of Z; but also refers to only the coefficient for X in this equation

- Conditional effect: the slope coefficients in the full regression model which can change. These are the lower-order terms associated with a variable. E.g., X has a conditional effect on Y. 

Which variable is the "predictor" (X) and which is the "moderator" (Z)?

---

The conditional nature of these effects is easiest to see by "plugging in" different values for one of your variables. Return to the regression equation estimated in our stress data:

```{r, echo = F}
imodel = lm(Stress ~ Anxiety*Support, data = stress.data)
C.vector = coef(summary(imodel))[,1]
C.round = round(C.vector,2)
```

$$\hat{Stress} = `r C.round[1]` + `r C.round[2]`(\text{Anx})+ `r C.round[3]`(\text{Sup})+ `r C.round[4]`(\text{Anx} \times \text{Sup})$$
--
**Set Support to 5**
$$
\begin{aligned}
\hat{Stress} &= `r C.round[1]` + `r C.round[2]`(\text{Anx})+ `r C.round[3]`(5)+ `r C.round[4]`(\text{Anx} \times 5) \\
&= `r C.round[1]` + `r C.round[2]`(\text{Anx})+ `r C.round[3]*5`+ `r C.round[4]*5`(\text{Anx}) \\
&= `r C.round[1] + C.round[3]*5` + `r C.round[2] + C.round[4]*5`(\text{Anx})
\end{aligned}
$$
--
**Set Support to 10**
$$
\begin{aligned}
\hat{Stress} &= `r C.round[1]` + `r C.round[2]`(\text{Anx})+ `r C.round[3]`(10)+ `r C.round[4]`(\text{Anx} \times 10) \\
&= `r C.round[1]` + `r C.round[2]`(\text{Anx})+ `r C.round[3]*10`+ `r C.round[4]*10`(\text{Anx}) \\
&= `r C.round[1] + C.round[3]*10` + `r C.round[2] + C.round[4]*10`(\text{Anx})
\end{aligned}
$$

---
## Plotting interactions

What is this plotting?

```{r, results = 'hide', message = F, warning = F, fig.width = 10, fig.height = 4}
library(sjPlot)
plot_model(imodel, type = "pred", term = "Support")
```

---
## Plotting interactions

What is this plotting?


```{r, results = 'hide', message = F, warning = F, fig.width = 10, fig.height = 4}
plot_model(imodel, type = "pred", terms = c("Support", "Anxiety[mean]"))
```

---

.pull-left[
```{r intplot1, results = 'hide', message = F, warning = F, echo = F}
plot_model(imodel, type = "pred", 
           terms = c("Support", 
                     "Anxiety[5,10]"))
```

```{r,ref.label="intplot1", eval = F}

```

Put values of the moderator in brackets!

]

.pull-right[
```{r intplot2, results = 'hide', message = F, warning = F, echo = F}
plot_model(imodel, type = "pred", 
           terms = c("Support", 
                     "Anxiety"), 
           mdrt.values = "meansd")
```

```{r,ref.label="intplot2", eval = F}

```
Put values of the moderator in argument `mdrt.values`!

]

---

## Testing simple slopes

```{r, message = F}
library(reghelper)

anx.vals = list(Anxiety = c(5,6,7))
simple_slopes(imodel, levels = anx.vals)
```

---

## Testing simple slopes

```{r}
m.anx = mean(stress.data$Anxiety)
s.anx = sd(stress.data$Anxiety)
anx.vals = list(Anxiety = c(m.anx - s.anx, 
                            m.anx,
                            m.anx + s.anx))

simple_slopes(imodel, levels = anx.vals)
```

---
## Simple slopes - Significance tests

What if you want to compare slopes to each other? How would we test this?

--

The test of the interaction coefficient is equivalent to the test of the difference in slopes at levels of Z separated by 1 unit. 

```{r,highlight.output = 5}
coef(summary(imodel))
```

---

## Centering

The regression equation built using the raw data is not only diffiuclt to interpret, but often the terms displayed are not relevant to the hypotheses we're interested. 
- $b_0$ is the expected value when all predictors are 0, but this may never happen in real life
- $b_1$ is the slope of X when Z is equal to 0, but this may not ever happen either. 

**Centering** your variables by subtracting the mean from all values can improve the interpretation of your results. 

- Remember, a linear transformation does not change associations (correlations) between variables. In this case, it only changes the interpretation for some coefficients
---

### Applying one function to multiple variables

```{r}
stress.c = stress.data %>%
  mutate(
    across( c(Anxiety, Support) , ~.x-mean(.x) )
    )

glimpse(stress.c)
```

---

### Model with centered predictors

```{r}
summary(lm(Stress ~ Anxiety*Support, data = stress.c))
```

---

### Model with uncentered predictors

```{r}
summary(lm(Stress ~ Anxiety*Support, data = stress.data))
```


---
 
## Standardized regression equation

If you're interested in getting the standardized regression equation, you can follow the procedure of standardizing your variables first and then entering them into your linear model.

An important note: You must take the product of the Z-scores, not the Z-score of the products to get the correct regression model. 

.pull-left[
#### This is OK
```{r, eval = F}
z(Y) ~ z(X) + z(Z) + z(X)*z(Z) 

z(Y) ~ z(X)*z(Z) 
```

]

.pull-right[
#### This is not OK

```{r, eval = F}
z(Y) ~ z(X) + z(Z) + z(X*Z) 
```

]

---

### Applying one function to all numeric variables
```{r}

stress.z = stress.data %>%
  mutate(across(where(is.numeric), scale)) 

head(stress.z)

```

---

### Standardized equation

```{r}
summary(lm(Stress ~ Anxiety*Support, stress.z))
```

---

### Unstandardized equation

```{r}
summary(lm(Stress ~ Anxiety*Support, stress.data))
```

---

# Interactions with two categorical variables

If both X and Z are categorical variables, the interpretation of coefficients is no longer the value of means and slopes, but means and differences in means. 

---

## Example

Recall our Solomon's paradox example from a few weeks ago:

```{r}
solomon = read.csv("https://raw.githubusercontent.com/uopsych/psy612/master/data/solomon.csv")
solomon = janitor::clean_names(solomon)

solomon$perspective = ifelse(solomon$condition %in% c(1,2), "self", "other")
solomon$distance = ifelse(solomon$condition %in% c(1,3), "immersed", "distanced")

head(solomon[,c("perspective", "distance", "wisdom")])
```

---

### Model summary

```{r, highlight.output = 11}
solomon.mod = lm(wisdom ~ perspective*distance, data = solomon)
summary(solomon.mod)
```

---

### Model summary
```{r, highlight.output = 12}
solomon.mod = lm(wisdom ~ perspective*distance, data = solomon)
summary(solomon.mod)
```

---

### Model summary
```{r, highlight.output = 13}
solomon.mod = lm(wisdom ~ perspective*distance, data = solomon)
summary(solomon.mod)
```

---

### Model summary
```{r, highlight.output = 14}
solomon.mod = lm(wisdom ~ perspective*distance, data = solomon)
summary(solomon.mod)
```

---

### Model summary
```{r, highlight.output = 21}
solomon.mod = lm(wisdom ~ perspective*distance, data = solomon)
summary(solomon.mod)
```

---

### Plotting results

```{r, fig.width=9, fig.height=6}
plot_model(solomon.mod, type = "pred", terms = c("distance", "perspective"))
```


---

Remember, regression and ANOVA are mathematically equivalent -- both divide the total variability in $Y$ into variability overlapping with ("explained by") the model and residual variability. 

What differs is the way results are presented. The regression framework is excellent for continuous variables, but interpreting the interactions of categorical variables is more difficult. So we'll switch back to the ANOVA framework next time and talk about...

---

class: inverse

## Next time

Factorial ANOVA
